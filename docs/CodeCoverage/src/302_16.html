<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\dev\ConvertX.To\src\Core\ConvertX.To.Application\Converters\ToJpgConverterBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.IO.Compression;
using System.Text;
using ConvertX.To.Application.Domain;
using ConvertX.To.Application.Exceptions;
using ConvertX.To.Application.Interfaces;
using ConvertX.To.Domain.Options;
using PdfSharp.Pdf;
using PdfSharp.Pdf.IO;

namespace ConvertX.To.Application.Converters;

public abstract class ToJpgConverterBase : MsGraphDriveItemConverterBase, IDisposable
{
    private readonly ConverterFactory _converterFactory;
    private readonly ILoggerAdapter&lt;IConverter&gt; _logger;
    private List&lt;InMemoryFile&gt; _convertedJpgStreams = new();

    private List&lt;InMemoryFile&gt; _splitPdfStreams = new();

    public ToJpgConverterBase(ConverterFactory converterFactory, string sourceFormat, string targetFormat,
        ILoggerAdapter&lt;IConverter&gt; logger, IMsGraphFileConversionService msGraphFileConversionService) : base(
        sourceFormat, targetFormat, logger, msGraphFileConversionService)
    {
        _converterFactory = converterFactory;
        _logger = logger;
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    public override async Task&lt;(string, Stream)&gt; ConvertAsync(Stream source, ConversionOptions conversionOptions)
    {
        if (!conversionOptions.ToJpgOptions.SplitIfPossible) return await base.ConvertAsync(source, conversionOptions);

        IConverter? toPdfConverter;

        try
        {
            toPdfConverter = _converterFactory.Create(_sourceFormat, &quot;pdf&quot;);
        }
        catch (UnsupportedConversionException _)
        {
            _logger.LogTrace(
                &quot;{option} was requested but there is no {sourceFormat} to {targetFormat} converter to use as an intermediary (proceeding with non-split conversion)&quot;,
                nameof(conversionOptions.ToJpgOptions.SplitIfPossible), _sourceFormat, &quot;pdf&quot;);
            return await base.ConvertAsync(source, conversionOptions);
        }

        var newConversionOptions = new ConversionOptions
        {
            ToJpgOptions = new ToJpgOptions
            {
                SplitIfPossible = false
            }
        };

        var (_, pdfStream) = await toPdfConverter.ConvertAsync(source, newConversionOptions);

        Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
        var sourcePdfDocument = PdfReader.Open(pdfStream, PdfDocumentOpenMode.Import);

        if (sourcePdfDocument.PageCount == 1)
        {
            source.Position = 0;
            return await base.ConvertAsync(source, conversionOptions);
        }

        _splitPdfStreams = SplitPdf(sourcePdfDocument);

        _convertedJpgStreams = await ConvertSplitPdfsToIndividualJpgs(_splitPdfStreams, newConversionOptions);

        var zippedJpgs = await ZipFilesAsync(_convertedJpgStreams);

        DisposeTemporaryStreams();

        return (&quot;zip&quot;, zippedJpgs);
    }

    private async Task&lt;List&lt;InMemoryFile&gt;&gt; ConvertSplitPdfsToIndividualJpgs(List&lt;InMemoryFile&gt; splitPdfStreams,
        ConversionOptions newConversionOptions)
    {
        var convertedPdfStreams = new List&lt;InMemoryFile&gt;();

        var pdfToJpgConverter = _converterFactory.Create(&quot;pdf&quot;, &quot;jpg&quot;);

        foreach (var splitPdfStream in splitPdfStreams)
        {
            var convertedPdfStream =
                await ConvertPdfStreamFileToJpgStreamFile(newConversionOptions, splitPdfStream, pdfToJpgConverter);
            convertedPdfStreams.Add(convertedPdfStream);
        }
        
        _logger.LogTrace(&quot;Converted {SplitPdfStreamsCount} PDFs to {ConvertedPdfStreamsCount} JPGs&quot;,
            splitPdfStreams.Count, convertedPdfStreams.Count);

        return convertedPdfStreams;
    }

    private async Task&lt;InMemoryFile&gt; ConvertPdfStreamFileToJpgStreamFile(ConversionOptions newConversionOptions,
        InMemoryFile splitPdfInMemory, IConverter pdfToJpgConverter)
    {
        var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(splitPdfInMemory.Name);

        var (_, jpgStream) = await pdfToJpgConverter.ConvertAsync(splitPdfInMemory.Stream, newConversionOptions);

        var convertedPdfStream = new InMemoryFile
        {
            Name = $&quot;{fileNameWithoutExtension}.jpg&quot;,
            Stream = jpgStream
        };
        
        _logger.LogTrace(&quot;Converted {SplitPdfInMemoryName} to {ConvertedPdfStreamName}&quot;, splitPdfInMemory.Name,
            convertedPdfStream.Name);
        
        return convertedPdfStream;
    }

    private List&lt;InMemoryFile&gt; SplitPdf(PdfDocument sourcePdfDocument)
    {
        var splitPdfStreams = new List&lt;InMemoryFile&gt;();

        for (var pageIndex = 0; pageIndex &lt; sourcePdfDocument.PageCount; pageIndex++)
        {
            var currentPageNumber = pageIndex + 1;

            var splitPdfFile = SplitPdfFile(sourcePdfDocument, pageIndex, currentPageNumber);

            splitPdfStreams.Add(splitPdfFile);
        }
        
        _logger.LogTrace(&quot;Split {SourcePdfDocumentPageCount} pages into {SplitPdfStreamsCount} PDFs&quot;,
            sourcePdfDocument.PageCount, splitPdfStreams.Count);

        return splitPdfStreams;
    }

    private static InMemoryFile SplitPdfFile(PdfDocument sourcePdfDocument, int pageIndex, int currentPageNumber)
    {
        var outputPdfDocument = new PdfDocument();

        outputPdfDocument.AddPage(sourcePdfDocument.Pages[pageIndex]);

        var fileName = $&quot;{currentPageNumber}_of_{sourcePdfDocument.PageCount}.pdf&quot;;

        var splitPdfFile = new InMemoryFile
        {
            Name = fileName,
            Stream = new MemoryStream()
        };

        outputPdfDocument.Save(splitPdfFile.Stream);
        return splitPdfFile;
    }

    private async Task&lt;Stream&gt; ZipFilesAsync(List&lt;InMemoryFile&gt; files)
    {
        var zipStream = new MemoryStream();

        using (var zip = new ZipArchive(zipStream, ZipArchiveMode.Create, true))
        {
            foreach (var file in files)
            {
                var entry = zip.CreateEntry(file.Name);
                await using var entryStream = entry.Open();
                await file.Stream.CopyToAsync(entryStream);
            }
        }

        zipStream.Position = 0;
        
        _logger.LogTrace(&quot;Zipped {Count} files into a single zip file&quot;, files.Count);
        return zipStream;
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposing) return;

        DisposeTemporaryStreams();

        _splitPdfStreams = new List&lt;InMemoryFile&gt;();
        _convertedJpgStreams = new List&lt;InMemoryFile&gt;();
    }

    private void DisposeTemporaryStreams()
    {
        foreach (var splitPdfStream in _splitPdfStreams) splitPdfStream.Stream.Dispose();

        foreach (var convertedJpgStream in _convertedJpgStreams) convertedJpgStream.Stream.Dispose();
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[16,5,16,61,1],[18,5,18,57,1],[21,106,22,74,1],[23,5,23,6,1],[24,9,24,46,1],[25,9,25,26,1],[26,5,26,6,1],[29,5,29,6,0],[30,9,30,23,0],[31,9,31,35,0],[32,5,32,6,0],[35,5,35,6,1],[36,9,36,61,1],[36,62,36,120,1],[41,9,41,10,1],[42,13,42,77,1],[43,9,43,10,1],[44,9,44,49,0],[45,9,45,10,0],[46,13,48,95,0],[49,13,49,71,0],[52,9,58,11,1],[60,9,60,94,1],[62,9,62,71,1],[63,9,63,87,1],[65,9,65,46,1],[66,9,66,10,1],[67,13,67,33,1],[68,13,68,71,1],[71,9,71,56,1],[73,9,73,111,1],[75,9,75,68,1],[77,9,77,35,1],[79,9,79,36,1],[80,5,80,6,1],[84,5,84,6,1],[85,9,85,60,1],[87,9,87,72,1],[89,9,89,16,1],[89,18,89,36,1],[89,37,89,39,1],[89,40,89,55,1],[90,9,90,10,1],[91,13,92,116,1],[93,13,93,57,1],[94,9,94,10,1],[96,9,97,63,1],[99,9,99,36,1],[100,5,100,6,1],[104,5,104,6,1],[105,9,105,96,1],[107,9,107,114,1],[109,9,113,11,1],[115,9,116,38,1],[118,9,118,35,1],[119,5,119,6,1],[122,5,122,6,1],[123,9,123,56,1],[125,14,125,31,1],[125,33,125,72,1],[125,74,125,85,1],[126,9,126,10,1],[127,13,127,51,1],[129,13,129,94,1],[131,13,131,47,1],[132,9,132,10,1],[134,9,135,65,1],[137,9,137,32,1],[138,5,138,6,1],[141,5,141,6,1],[142,9,142,51,1],[144,9,144,71,1],[146,9,146,84,1],[148,9,152,11,1],[154,9,154,53,1],[155,9,155,29,1],[156,5,156,6,1],[159,5,159,6,1],[160,9,160,44,1],[162,16,162,80,1],[163,9,163,10,1],[164,13,164,20,1],[164,22,164,30,1],[164,31,164,33,1],[164,34,164,39,1],[165,13,165,14,1],[166,17,166,56,1],[167,17,167,60,1],[168,17,168,60,1],[169,13,169,14,1],[170,9,170,10,1],[172,9,172,32,1],[174,9,174,86,1],[175,9,175,26,1],[176,5,176,6,1],[179,5,179,6,0],[180,9,180,24,0],[180,25,180,32,0],[182,9,182,35,0],[184,9,184,53,0],[185,9,185,57,0],[186,5,186,6,0],[189,5,189,6,1],[190,9,190,16,1],[190,18,190,36,1],[190,37,190,39,1],[190,40,190,56,1],[190,58,190,90,1],[192,9,192,16,1],[192,18,192,40,1],[192,41,192,43,1],[192,44,192,64,1],[192,66,192,102,1],[193,5,193,6,1]]);
    </script>
  </body>
</html>